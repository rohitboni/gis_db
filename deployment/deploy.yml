---
- name: Deploy GIS DB API Application - DATA SAFE VERSION
  hosts: aws_servers
  become: yes
  vars:
    project_name: "gis_db"
    project_dir: "/opt/{{ project_name }}"
    zip_file: "{{ project_name }}.zip"
    domain: "gis-portal.1acre.in"  # Domain for SSL certificate

  tasks:
    # ===================================
    # STEP 1: PREPARE LOCAL DEPLOYMENT
    # ===================================
    
    - name: Get local project directory path (parent of deployment directory)
      set_fact:
        local_project_dir: "{{ playbook_dir | dirname }}"
      delegate_to: localhost
      run_once: true
      become: no

    - name: Display local project directory
      debug:
        msg: "Local project directory: {{ local_project_dir }}"
      delegate_to: localhost
      run_once: true
      become: no

    - name: Check if local project directory exists
      stat:
        path: "{{ local_project_dir }}"
      delegate_to: localhost
      run_once: true
      become: no
      register: local_project_stat

    - name: Fail if local project directory doesn't exist
      fail:
        msg: "Local project directory not found: {{ local_project_dir }}. Please run this playbook from the deployment directory."
      when: not local_project_stat.stat.exists
      delegate_to: localhost
      run_once: true
      become: no

    - name: Clean up old zip files on local machine
      file:
        path: "/tmp/{{ zip_file }}"
        state: absent
      delegate_to: localhost
      run_once: true
      become: no
      ignore_errors: yes

    - name: Create zip archive from local project directory
      shell: |
        cd "{{ local_project_dir }}"
        # Remove old zip if exists
        rm -f "/tmp/{{ zip_file }}"
        # Create zip excluding unnecessary files
        zip -r "/tmp/{{ zip_file }}" . \
          -x "venv/*" \
          -x "__pycache__/*" \
          -x "*.pyc" \
          -x "*.pyo" \
          -x ".git/*" \
          -x ".pytest_cache/*" \
          -x ".DS_Store" \
          -x "*.log" \
          -x ".idea/*" \
          -x "*.swp" \
          -x "*.swo" \
          -x "*~" \
          -x "*.pem" \
          -x "*.env" \
          -x ".env" \
          -x "env.example" 2>&1
      delegate_to: localhost
      run_once: true
      become: no

    - name: Verify zip file was created
      stat:
        path: "/tmp/{{ zip_file }}"
      delegate_to: localhost
      run_once: true
      become: no
      register: zip_file_stat

    - name: Fail if zip file creation failed
      fail:
        msg: "Failed to create zip file: /tmp/{{ zip_file }}"
      when: not zip_file_stat.stat.exists
      delegate_to: localhost
      run_once: true
      become: no

    - name: Display zip file info
      debug:
        msg: "Created zip file: /tmp/{{ zip_file }} ({{ ((zip_file_stat.stat.size | default(0)) / 1024 / 1024) | round(2) }} MB)"
      delegate_to: localhost
      run_once: true
      become: no

    - name: Upload zip file to server
      copy:
        src: "/tmp/{{ zip_file }}"
        dest: "/tmp/{{ zip_file }}"
        mode: '0644'

    # ===================================
    # STEP 2: DOCKER INSTALLATION
    # ===================================
    
    - name: Check if Docker is installed
      command: which docker
      register: docker_installed
      ignore_errors: yes

    - name: Update apt cache
      apt:
        update_cache: yes
      when: docker_installed.rc != 0

    - name: Install required packages for Docker
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - software-properties-common
          - unzip
        state: present
      when: docker_installed.rc != 0

    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      when: docker_installed.rc != 0

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
      when: docker_installed.rc != 0

    - name: Install Docker
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
        update_cache: yes
      when: docker_installed.rc != 0

    - name: Install Docker Compose standalone
      get_url:
        url: "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64"
        dest: /usr/local/bin/docker-compose
        mode: '0755'
      when: docker_installed.rc != 0

    - name: Create docker-compose symlink
      file:
        src: /usr/local/bin/docker-compose
        dest: /usr/bin/docker-compose
        state: link
      when: docker_installed.rc != 0
      ignore_errors: yes

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Add ubuntu user to docker group
      user:
        name: ubuntu
        groups: docker
        append: yes

    - name: Reset ssh connection to apply group changes
      meta: reset_connection

    # ===================================
    # STEP 3: SAFE CLEANUP (PRESERVE DATA)
    # ===================================
    
    - name: Check initial disk space
      shell: df -h
      register: initial_disk_space

    - name: Display initial disk usage
      debug:
        msg: "Initial disk usage: {{ initial_disk_space.stdout }}"

    - name: Check if project directory exists
      stat:
        path: "{{ project_dir }}"
      register: project_exists

    - name: Stop existing Docker containers (preserve volumes)
      shell: docker-compose down --remove-orphans
      args:
        chdir: "{{ project_dir }}/deployment"
      when: project_exists.stat.exists
      ignore_errors: yes
      become_user: ubuntu

    - name: Wait for containers to stop completely
      pause:
        seconds: 10
      when: project_exists.stat.exists

    # SAFE cleanup - preserves data volumes
    - name: Clean up unused containers only
      shell: docker container prune -f
      ignore_errors: yes

    - name: Clean up unused images only
      shell: docker image prune -af
      ignore_errors: yes

    - name: Clean up unused networks only
      shell: docker network prune -f
      ignore_errors: yes

    - name: Clean up build cache only
      shell: docker builder prune -af
      ignore_errors: yes

    - name: Show preserved volumes
      shell: docker volume ls
      register: preserved_volumes
      ignore_errors: yes

    - name: Display preserved volumes
      debug:
        msg: "Preserved volumes: {{ preserved_volumes.stdout }}"
      when: preserved_volumes.stdout is defined

    - name: Check disk space after cleanup
      shell: df -h
      register: cleaned_disk_space

    - name: Display disk space after cleanup
      debug:
        msg: "Disk space after cleanup: {{ cleaned_disk_space.stdout }}"

    # Clean up old project code (but preserve data)
    - name: Remove old project directory (code only)
      shell: rm -rf "{{ project_dir }}"
      ignore_errors: yes

    - name: Create fresh project directory
      file:
        path: "{{ project_dir }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    # ===================================
    # STEP 4: DEPLOY NEW CODE
    # ===================================
    
    - name: Extract zip file directly to project directory
      unarchive:
        src: "/tmp/{{ zip_file }}"
        dest: "{{ project_dir }}"
        remote_src: yes
        owner: ubuntu
        group: ubuntu

    - name: Ensure all extracted files have correct ownership
      file:
        path: "{{ project_dir }}"
        owner: ubuntu
        group: ubuntu
        recurse: yes
      become: yes

    # ===================================
    # STEP 5: SSL CERTIFICATE CREATION/RENEWAL
    # ===================================
    
    - name: Stop and disable host nginx to avoid port conflicts
      systemd:
        name: nginx
        state: stopped
        enabled: no
      ignore_errors: yes

    - name: Remove existing nginx sites that might conflict
      file:
        path: "/etc/nginx/sites-enabled/{{ domain }}"
        state: absent
      ignore_errors: yes

    - name: Stop any existing Docker containers to free ports 80/443
      shell: |
        if [ -d "{{ project_dir }}/deployment" ] && [ -f "{{ project_dir }}/deployment/docker-compose.yml" ]; then
          cd "{{ project_dir }}/deployment" && docker-compose down --remove-orphans || true
        fi
        # Also stop any containers using ports 80/443
        docker ps --filter "publish=80" --filter "publish=443" -q | xargs -r docker stop || true
      ignore_errors: yes
      become_user: ubuntu

    - name: Wait for ports to be free
      pause:
        seconds: 5

    - name: Check if certbot is installed
      command: which certbot
      register: certbot_installed
      ignore_errors: yes

    - name: Install certbot and python3-certbot-nginx
      apt:
        name:
          - certbot
          - python3-certbot-nginx
        state: present
        update_cache: yes
      when: certbot_installed.rc != 0

    - name: Check if SSL certificate exists for our domain
      stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert

    - name: Check certificate expiry date if it exists
      shell: |
        if [ -f "/etc/letsencrypt/live/{{ domain }}/fullchain.pem" ]; then
          openssl x509 -enddate -noout -in /etc/letsencrypt/live/{{ domain }}/fullchain.pem | cut -d= -f2
        else
          echo "NOT_EXISTS"
        fi
      register: cert_expiry
      ignore_errors: yes

    - name: Display SSL certificate status
      debug:
        msg: |
          SSL Certificate Status:
          - Exists: {{ ssl_cert.stat.exists }}
          - Expiry: {{ cert_expiry.stdout if cert_expiry.stdout is defined else 'N/A' }}

    - name: Remove old certificate to force new certificate generation
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/etc/letsencrypt/live/{{ domain }}"
        - "/etc/letsencrypt/archive/{{ domain }}"
        - "/etc/letsencrypt/renewal/{{ domain }}.conf"
      ignore_errors: yes

    - name: Create new SSL certificate using standalone mode
      shell: |
        # Use standalone mode since nginx is not running
        # Always create a fresh certificate on every deployment
        certbot certonly \
          --standalone \
          --non-interactive \
          --agree-tos \
          --email admin@1acre.in \
          --preferred-challenges http \
          -d "{{ domain }}" \
          --expand
      register: certbot_result
      ignore_errors: yes

    - name: Retry certificate creation if first attempt failed
      shell: |
        certbot certonly \
          --standalone \
          --non-interactive \
          --agree-tos \
          --email admin@1acre.in \
          --preferred-challenges http \
          -d "{{ domain }}"
      when: certbot_result.rc != 0
      ignore_errors: yes

    - name: Verify SSL certificate was created/renewed
      stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert_after

    - name: Display SSL certificate creation result
      debug:
        msg: |
          {% if ssl_cert_after.stat.exists %}
          ‚úÖ SSL certificate successfully created/renewed for {{ domain }}
          Certificate path: /etc/letsencrypt/live/{{ domain }}/fullchain.pem
          {% else %}
          ‚ö†Ô∏è SSL certificate creation may have failed. Please check manually.
          {% endif %}

    - name: Set up automatic SSL renewal cron job
      cron:
        name: "SSL certificate renewal"
        job: 'cd "{{ project_dir }}/deployment" && docker-compose stop nginx || true && sleep 5 && certbot renew --standalone --non-interactive --preferred-challenges http && cd "{{ project_dir }}/deployment" && docker-compose start nginx || true'
        minute: "0"
        hour: "3"
        user: root

    # ===================================
    # STEP 6: PREPARE NGINX CONFIGURATION
    # ===================================

    - name: Create nginx configuration directory for Docker
      file:
        path: "{{ project_dir }}/deployment/nginx/conf.d"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'

    - name: Create Docker nginx configuration
      copy:
        dest: "{{ project_dir }}/deployment/nginx/conf.d/default.conf"
        content: |
          server {
              listen 80;
              server_name {{ domain }};
              return 301 https://$server_name$request_uri;
          }

          server {
              listen 443 ssl http2;
              server_name {{ domain }};

              ssl_certificate /etc/letsencrypt/live/{{ domain }}/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/{{ domain }}/privkey.pem;
              
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
              ssl_prefer_server_ciphers off;
              add_header Strict-Transport-Security "max-age=63072000" always;

              client_max_body_size 100M;

              location / {
                  proxy_pass http://web:8000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_connect_timeout 300s;
                  proxy_send_timeout 300s;
                  proxy_read_timeout 300s;
              }

              location /docs {
                  proxy_pass http://web:8000/docs;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }

              location /redoc {
                  proxy_pass http://web:8000/redoc;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }
          }

    # ===================================
    # STEP 7: BUILD AND START CONTAINERS (INCLUDING DOCKER NGINX)
    # ===================================
    
    - name: Create necessary directories
      file:
        path: "{{ item }}"
        state: directory
        owner: ubuntu
        group: ubuntu
        mode: '0755'
      loop:
        - "{{ project_dir }}/logs"

    - name: Build Docker containers (no cache for fresh build)
      shell: docker-compose build --no-cache
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu

    - name: Start Docker containers (including nginx)
      shell: docker-compose up -d
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu

    - name: Wait for nginx container to be ready
      wait_for:
        port: 443
        host: "0.0.0.0"
        delay: 30
        timeout: 300
      become: no

    - name: Wait additional time for web container to be ready
      pause:
        seconds: 30

    - name: Check container status before database init
      shell: docker-compose ps
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu
      register: container_status_pre

    - name: Display container status
      debug:
        msg: "Container status before database init: {{ container_status_pre.stdout }}"

    - name: Verify database is ready
      shell: docker-compose exec -T db pg_isready -U postgres
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu
      register: db_ready
      retries: 5
      delay: 10
      until: db_ready.rc == 0

    # ===================================
    # STEP 8: DATABASE INITIALIZATION
    # ===================================
    
    - name: Wait for database to be fully initialized
      pause:
        seconds: 10

    - name: Verify PostGIS extensions are installed
      shell: docker-compose exec -T db psql -U postgres -d gis_db -c "SELECT extname FROM pg_extension WHERE extname LIKE '%postgis%';"
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu
      register: postgis_check
      ignore_errors: yes

    - name: Display PostGIS extensions
      debug:
        msg: "PostGIS extensions installed: {{ postgis_check.stdout }}"
      when: postgis_check.stdout is defined

    - name: Verify FastAPI application initialized database tables
      shell: docker-compose logs web | grep -i "initialized\|table\|postgis" | tail -20
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu
      register: app_init_logs
      ignore_errors: yes

    - name: Display application initialization logs
      debug:
        msg: "Application initialization: {{ app_init_logs.stdout }}"
      when: app_init_logs.stdout is defined

    # ===================================
    # STEP 9: CLEANUP & FINAL STATUS
    # ===================================
    
    - name: Remove uploaded zip file
      file:
        path: "/tmp/{{ zip_file }}"
        state: absent

    - name: Clean up local zip file
      file:
        path: "/tmp/{{ zip_file }}"
        state: absent
      delegate_to: localhost
      run_once: true
      become: no
      ignore_errors: yes

    - name: Clean up local zip file
      file:
        path: "/tmp/{{ zip_file }}"
        state: absent
      delegate_to: localhost
      run_once: true
      become: no

    - name: Final disk space check
      shell: df -h
      register: final_disk_space

    - name: Display final disk usage
      debug:
        msg: "Final disk usage: {{ final_disk_space.stdout }}"

    - name: Show container status
      shell: docker-compose ps
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu
      register: container_status

    - name: Test application health
      uri:
        url: "https://{{ domain }}/health"
        method: GET
        timeout: 10
      register: health_check
      ignore_errors: yes

    # ===================================
    # VERIFY DATA PRESERVATION
    # ===================================
    
    - name: Verify database data is preserved
      shell: |
        docker-compose exec -T db psql -U postgres -d gis_db -c "
        SELECT 
          schemaname,
          relname as tablename,
          n_tup_ins as inserts,
          n_tup_upd as updates,
          n_tup_del as deletes
        FROM pg_stat_user_tables 
        WHERE schemaname = 'public'
        ORDER BY relname;
        "
      args:
        chdir: "{{ project_dir }}/deployment"
      become_user: ubuntu
      register: db_stats
      ignore_errors: yes

    - name: Display database preservation status
      debug:
        msg: |
          üìä Database Stats (Data Preserved):
          {{ db_stats.stdout }}
      when: db_stats.stdout is defined

    # ===================================
    # DEPLOYMENT SUCCESS MESSAGE
    # ===================================
    
    - name: Display deployment status
      debug:
        msg: |
          üéâ DATA-SAFE DEPLOYMENT COMPLETED SUCCESSFULLY!
          
          üì¶ Deployed Branch: master
          
          üåê Application URLs:
            - HTTPS: https://{{ domain }}
            - API Docs: https://{{ domain }}/docs
            - ReDoc: https://{{ domain }}/redoc
            - Health: https://{{ domain }}/health
            - Health Status: {{ 'PASSED' if health_check.status == 200 else 'FAILED' }}
          
          üìä Container Status:
          {{ container_status.stdout }}
          
          üíæ Disk Usage:
          {{ final_disk_space.stdout }}
          
          üõ°Ô∏è DATA PRESERVATION STATUS:
            ‚úÖ PostgreSQL data preserved (named volumes)
            ‚úÖ SSL certificates preserved and working
            ‚úÖ No data loss during deployment
            ‚úÖ Docker nginx configured with existing SSL certificate
          
          üóÇÔ∏è Key Features:
            ‚úÖ PostgreSQL with PostGIS extensions
            ‚úÖ FastAPI with automatic API documentation
            ‚úÖ SSL certificate with auto-renewal ({{ domain }})
            ‚úÖ Production settings (DEBUG=False)
            ‚úÖ Data-safe deployment process
            ‚úÖ Docker nginx with SSL (host nginx disabled)
          
          üîß Useful Commands:
            - Check containers: docker-compose ps
            - View logs: docker-compose logs -f web
            - View nginx logs: docker-compose logs -f nginx
            - Database access: docker-compose exec db psql -U postgres gis_db
            - Check volumes: docker volume ls
            - Monitor disk: df -h
            - Restart nginx: docker-compose restart nginx
            - Test nginx config: docker-compose exec nginx nginx -t
          
          üìÅ Project Directory: {{ project_dir }}
          
          ‚ö†Ô∏è IMPORTANT NOTES:
            üî• Your database data has been PRESERVED across this deployment
            üî• Production-ready with SSL and security settings
            üî• Using Docker nginx with existing SSL certificates for {{ domain }}
            üî• Host nginx has been stopped to avoid port conflicts
          
          üåü Your data-safe GIS DB API deployment is complete!
